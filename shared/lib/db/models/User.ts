import { Schema, Model, Document, Connection } from "mongoose";
import connectToUserDb from "../connections/userDb";

// Define the TypeScript interface for User documents
export interface IUser extends Document {
  userId: number; // Unique numeric user identifier
  firstName: string; // User's first name
  lastName: string | null; // User's last name (nullable)
  email: string; // Unique email (lowercased)
  password: string | null; // Password (nullable if logged in with OAuth)
  profilePic: string | null; // Profile picture URL (nullable)

  // Auth providers (credentials, google, github)
  loggedBy: ("credentials" | "google" | "github")[];

  // Balance object (diamond, coin, life)
  balance: {
    diamond: number;
    coin: number;
    life: number;
  };

  referredBy: number | null; // Refers to another user's userId

  createdAt: Date; // Auto-generated by timestamps
  updatedAt: Date; // Auto-generated by timestamps
}

// Define the schema with validations & defaults
const userSchema = new Schema<IUser>(
  {
    userId: { type: Number, unique: true, required: true }, // Unique numeric user identifier
    firstName: { type: String, required: true }, // User's first name
    lastName: { type: String, default: null }, // User's last name (nullable)
    email: { type: String, required: true, unique: true, lowercase: true }, // Unique email
    password: { type: String, default: null }, // Nullable password
    profilePic: { type: String, default: null }, // Nullable profile picture

    loggedBy: {
      type: [String],
      default: ["credentials"],
      enum: ["credentials", "google", "github"], // Supported login methods
    },

    // Balance object stored as a Map with numeric values
    balance: {
      type: Map,
      of: Number,
      default: {
        diamond: 0,
        coin: 0,
        life: 0,
      },
    },

    referredBy: { type: Number, default: null }, // Refers to another user's userId
  },
  { timestamps: true } // Automatically handles createdAt and updatedAt
);

// Using mongoose models and checking for existing models to prevent overwriting
let cachedModel: Model<IUser> | null = null;

export default async function getUserModel(): Promise<Model<IUser>> {
  const conn: Connection = await connectToUserDb();
  if (!cachedModel) {
    cachedModel = conn.models.User || conn.model<IUser>("User", userSchema);
  }
  return cachedModel;
}
